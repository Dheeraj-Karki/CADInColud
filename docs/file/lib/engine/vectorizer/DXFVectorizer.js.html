<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">lib/engine/vectorizer/DXFVectorizer.js | cadincloud</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="CAD in cloud"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="cadincloud"><meta property="twitter:description" content="CAD in cloud"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a href="https://KarkiCoder@bitbucket.org/KarkiCoder/cadincloud.git">Repository</a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#engine-controller">engine/controller</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/engine/controller/Controller.js~Controller.html">Controller</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/engine/controller/OrbitController.js~OrbitController.html">OrbitController</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#engine-vectorizer">engine/vectorizer</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/engine/vectorizer/DXFVectorizer.js~DXFVectorizer.html">DXFVectorizer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/engine/vectorizer/Vectorizer.js~Vectorizer.html">Vectorizer</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#engine-viewer">engine/viewer</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/engine/viewer/DXFViewer.js~DXFViewer.html">DXFViewer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/lib/engine/viewer/Viewer.js~Viewer.html">Viewer</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parsers">parsers</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/DXFParser.js~DXFParser.html">DXFParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/lib/parsers/Parser.js~Parser.html">Parser</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parsers-dxf-entities">parsers/dxf/entities</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/Arc.js~Arc.html">Arc</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/AttDef.js~AttDef.html">AttDef</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/Circle.js~Circle.html">Circle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/Dimension.js~Dimension.html">Dimension</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/Ellipse.js~Ellipse.html">Ellipse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/Insert.js~Insert.html">Insert</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/LWPolyline.js~LWPolyline.html">LWPolyline</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/Line.js~Line.html">Line</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/Mtext.js~Mtext.html">Mtext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/Point.js~Point.html">Point</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/Solid.js~Solid.html">Solid</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/Spline.js~Spline.html">Spline</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/Text.js~Text.html">Text</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/Vertex.js~Vertex.html">Vertex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/lib/parsers/dxf/entities/EntityParser.js~EntityParser.html">EntityParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instance">instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instance">instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instance">instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instance">instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instance">instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instance">instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instance">instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instance">instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instance">instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instance">instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instance">instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instance">instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instance">instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-instance">instance</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scanners">scanners</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/scanners/DXFScanner.js~DXFScanner.html">DXFScanner</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/lib/scanners/Scanner.js~Scanner.html">Scanner</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/engine/vectorizer/DXFVectorizer.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import * as THREE from &apos;three&apos;;
import Vectorizer from &apos;./Vectorizer&apos;;

/**
 * Returns the angle in radians of the vector (p1,p2). In other words, imagine
 * putting the base of the vector at coordinates (0,0) and finding the angle
 * from vector (1,0) to (p1,p2).
 * @param  {Object} p1 start point of the vector
 * @param  {Object} p2 end point of the vector
 * @return {Number} the angle
 */
THREE.Math.angle2 = function (p1, p2) {
    let v1 = new THREE.Vector2(p1.x, p1.y);
    let v2 = new THREE.Vector2(p2.x, p2.y);
    v2.sub(v1); // sets v2 to be our chord
    v2.normalize();
    if (v2.y &lt; 0) return -Math.acos(v2.x);
    return Math.acos(v2.x);
};

THREE.Math.polar = function (point, distance, angle) {
    let result = {};
    result.x = point.x + distance * Math.cos(angle);
    result.y = point.y + distance * Math.sin(angle);
    return result;
};

/**
 * Calculates points for a curve between two points
 * @param startPoint - the starting point of the curve
 * @param endPoint - the ending point of the curve
 * @param bulge - a value indicating how much to curve
 * @param segments - number of segments between the two given points
 */
THREE.BulgeGeometry = function (startPoint, endPoint, bulge, segments) {

    let vertex, i, center, p0, p1, angle, radius, startAngle, thetaAngle;

    THREE.Geometry.call(this);

    this.startPoint = p0 = startPoint ? new THREE.Vector2(startPoint.x, startPoint.y) : new THREE.Vector2(0, 0);
    this.endPoint = p1 = endPoint ? new THREE.Vector2(endPoint.x, endPoint.y) : new THREE.Vector2(1, 0);
    this.bulge = bulge = bulge || 1;

    angle = 4 * Math.atan(bulge);
    radius = p0.distanceTo(p1) / 2 / Math.sin(angle / 2);
    center = THREE.Math.polar(startPoint, radius, THREE.Math.angle2(p0, p1) + (Math.PI / 2 - angle / 2));

    this.segments = segments = segments || Math.max(Math.abs(Math.ceil(angle / (Math.PI / 18))), 6); // By default want a segment roughly every 10 degrees
    startAngle = THREE.Math.angle2(center, p0);
    thetaAngle = angle / segments;

    this.vertices.push(new THREE.Vector3(p0.x, p0.y, 0));

    for (i = 1; i &lt;= segments - 1; i++) {

        vertex = THREE.Math.polar(center, Math.abs(radius), startAngle + thetaAngle * i);

        this.vertices.push(new THREE.Vector3(vertex.x, vertex.y, 0));
    }
};

THREE.BulgeGeometry.prototype = Object.create(THREE.Geometry.prototype);

/**
 * @public
 * @extends {Vectorizer}
 * @example 
 * let dxfVectorizer = new DXFVectorizer()
 */
export default class DXFVectorizer extends Vectorizer {
    /**
     * Creates an instance of DXFVectorizer.
     * @constructor
     * @memberof DXFVectorizer
     */
    constructor() {
        super();
        this.font;
    }

    /**
     * Vectorize to draw
     * @param {Object} entity - entity dxfDb
     * @param {Object} dxfDb - dxf Database
     * @return {THREE.Mesh}
     * @memberof DXFVectorizer
     */
    drawEntity(entity, dxfDb) {
        let mesh;
        if (entity.type === &apos;CIRCLE&apos; || entity.type === &apos;ARC&apos;) {
            mesh = this.__drawArc(entity, dxfDb);
        } else if (entity.type === &apos;LWPOLYLINE&apos; || entity.type === &apos;LINE&apos; || entity.type === &apos;POLYLINE&apos;) {
            mesh = this.__drawLine(entity, dxfDb);
        } else if (entity.type === &apos;TEXT&apos;) {
            mesh = this.__drawText(entity, dxfDb);
        } else if (entity.type === &apos;SOLID&apos;) {
            mesh = this.__drawSolid(entity, dxfDb);
        } else if (entity.type === &apos;POINT&apos;) {
            mesh = this.__drawPoint(entity, dxfDb);
        } else if (entity.type === &apos;INSERT&apos;) {
            mesh = this.__drawBlock(entity, dxfDb);
        } else if (entity.type === &apos;SPLINE&apos;) {
            mesh = this.__drawSpline(entity, dxfDb);
        } else if (entity.type === &apos;MTEXT&apos;) {
            mesh = this.__drawMtext(entity, dxfDb);
        } else if (entity.type === &apos;ELLIPSE&apos;) {
            mesh = this.__drawEllipse(entity, dxfDb);
        } else {
            console.log(&quot;Unsupported Entity Type: &quot; + entity.type);
        }
        return mesh;
    }
    /**
     * Vectorize Ellipse
     * @private
     * @param {Object} entity - entity dxfDb
     * @param {Object} dxfDb - dxf Database
     * @return {THREE.Mesh}
     * @memberof DXFVectorizer
     */
    __drawEllipse(entity, dxfDb) {
        let color = this.__getColor(entity, dxfDb);

        let xrad = Math.sqrt(Math.pow(entity.majorAxisEndPoint.x, 2) + Math.pow(entity.majorAxisEndPoint.y, 2));
        let yrad = xrad * entity.axisRatio;
        let rotation = Math.atan2(entity.majorAxisEndPoint.y, entity.majorAxisEndPoint.x);

        let curve = new THREE.EllipseCurve(entity.center.x, entity.center.y, xrad, yrad, entity.startAngle, entity.endAngle, false, // Always counterclockwise
            rotation);

        let points = curve.getPoints(50);
        let geometry = new THREE.BufferGeometry().setFromPoints(points);
        let material = new THREE.LineBasicMaterial({
            linewidth: 1,
            color: color
        });

        // Create the final object to add to the scene
        return new THREE.Line(geometry, material);
    }
    /**
     * Vectorize Line
     * @private
     * @param {Object} entity - entity dxfDb
     * @param {Object} dxfDb - dxf Database
     * @return {THREE.Mesh}
     * @memberof DXFVectorizer
     */
    __drawLine(entity, dxfDb) {
        let geometry = new THREE.Geometry(),
            color = this.__getColor(entity, dxfDb),
            material,
            lineType;

        // create geometry
        for (let i = 0; i &lt; entity.vertices.length; i++) {

            if (entity.vertices[i].bulge) {
                let bulge = entity.vertices[i].bulge;
                let startPoint = entity.vertices[i];
                let endPoint = i + 1 &lt; entity.vertices.length ? entity.vertices[i + 1] : geometry.vertices[0];

                let bulgeGeometry = new THREE.BulgeGeometry(startPoint, endPoint, bulge);

                geometry.vertices.push.apply(geometry.vertices, bulgeGeometry.vertices);
            } else {
                let vertex = entity.vertices[i];
                geometry.vertices.push(new THREE.Vector3(vertex.x, vertex.y, 0));
            }
        }
        if (entity.shape) geometry.vertices.push(geometry.vertices[0]);

        // set material
        if (entity.lineType) {
            lineType = dxfDb.tables.LTYPE.LTYPE[entity.lineType];
        }

        if (lineType &amp;&amp; lineType.pattern &amp;&amp; lineType.pattern.length !== 0) {
            material = new THREE.LineDashedMaterial({
                color: color,
                gapSize: 4,
                dashSize: 4
            });
        } else {
            material = new THREE.LineBasicMaterial({
                linewidth: 1,
                color: color
            });
        }

        // if(lineType &amp;&amp; lineType.pattern &amp;&amp; lineType.pattern.length !== 0) {

        //           geometry.computeLineDistances();

        //           // Ugly hack to add diffuse to this. Maybe copy the uniforms object so we
        //           // don&apos;t add diffuse to a material.
        //           lineType.material.uniforms.diffuse = { type: &apos;c&apos;, value: new THREE.Color(color) };

        // 	material = new THREE.ShaderMaterial({
        // 		uniforms: lineType.material.uniforms,
        // 		vertexShader: lineType.material.vertexShader,
        // 		fragmentShader: lineType.material.fragmentShader
        // 	});
        // }else {
        // 	material = new THREE.LineBasicMaterial({ linewidth: 1, color: color });
        // }
        return new THREE.Line(geometry, material);
    }


    /**
     * Vectorize Mtext
     * @private
     * @param {Object} entity - entity dxfDb
     * @param {Object} dxfDb - dxf Database
     * @return {THREE.Mesh}
     * @memberof DXFVectorizer
     */
    __drawMtext(entity, dxfDb) {

        if (!this.font) return console.warn(&apos;MText is not supported without a Three.js font loaded with THREE.FontLoader! Load a font of your choice and pass this into the constructor. See the sample for this repository or Three.js examples at http://threejs.org/examples/?q=text#webgl_geometry_text for more details.&apos;);

        let color = this.__getColor(entity, dxfDb);

        let geometry = new THREE.TextGeometry(entity.text, {
            font: this.font,
            size: entity.height * (4 / 5),
            height: 1
        });
        let material = new THREE.MeshBasicMaterial({
            color: color
        });
        let text = new THREE.Mesh(geometry, material);

        // Measure what we rendered.
        let measure = new THREE.Box3();
        measure.setFromObject(text);

        let textWidth = measure.max.x - measure.min.x;

        // If the text ends up being wider than the box, it&apos;s supposed
        // to be multiline. Doing that in threeJS is overkill.
        if (entity.width != 0 &amp;&amp; textWidth &gt; entity.width) {
            console.log(&quot;Can&apos;t render this multipline MTEXT entity, sorry.&quot;, entity);
            return undefined;
        }

        text.position.z = 0;
        switch (entity.attachmentPoint) {
            case 1:
                // Top Left
                text.position.x = entity.position.x;
                text.position.y = entity.position.y - entity.height;
                break;
            case 2:
                // Top Center
                text.position.x = entity.position.x - textWidth / 2;
                text.position.y = entity.position.y - entity.height;
                break;
            case 3:
                // Top Right
                text.position.x = entity.position.x - textWidth;
                text.position.y = entity.position.y - entity.height;
                break;

            case 4:
                // Middle Left
                text.position.x = entity.position.x;
                text.position.y = entity.position.y - entity.height / 2;
                break;
            case 5:
                // Middle Center
                text.position.x = entity.position.x - textWidth / 2;
                text.position.y = entity.position.y - entity.height / 2;
                break;
            case 6:
                // Middle Right
                text.position.x = entity.position.x - textWidth;
                text.position.y = entity.position.y - entity.height / 2;
                break;

            case 7:
                // Bottom Left
                text.position.x = entity.position.x;
                text.position.y = entity.position.y;
                break;
            case 8:
                // Bottom Center
                text.position.x = entity.position.x - textWidth / 2;
                text.position.y = entity.position.y;
                break;
            case 9:
                // Bottom Right
                text.position.x = entity.position.x - textWidth;
                text.position.y = entity.position.y;
                break;

            default:
                return undefined;
        };
        return text;
    }

    /**
     * Vectorize Spline
     * @private
     * @param {Object} entity - entity dxfDb
     * @param {Object} dxfDb - dxf Database
     * @return {THREE.Mesh}
     * @memberof DXFVectorizer
     */
    __drawSpline(entity, dxfDb) {
        let color = this.__getColor(entity, dxfDb);

        let points = entity.controlPoints.map(function (vec) {
            return new THREE.Vector2(vec.x, vec.y);
        });

        let interpolatedPoints = [];
        let curve = null;
        if (entity.degreeOfSplineCurve === 2 || entity.degreeOfSplineCurve === 3) {
            for (let i = 0; i + 2 &lt; points.length; i = i + 2) {
                if (entity.degreeOfSplineCurve === 2) {
                    curve = new THREE.QuadraticBezierCurve(points[i], points[i + 1], points[i + 2]);
                } else {
                    curve = new THREE.QuadraticBezierCurve3(points[i], points[i + 1], points[i + 2]);
                }
                interpolatedPoints.push.apply(interpolatedPoints, curve.getPoints(50));
            }
        } else {
            curve = new THREE.SplineCurve(points);
            interpolatedPoints = curve.getPoints(100);
        }

        let geometry = new THREE.BufferGeometry().setFromPoints(interpolatedPoints);
        let material = new THREE.LineBasicMaterial({
            linewidth: 1,
            color: color
        });
        let splineObject = new THREE.Line(geometry, material);

        return splineObject;
    }

    /**
     * Vectorize Arc/Circle
     * @private
     * @param {Object} entity - entity dxfDb
     * @param {Object} dxfDb - dxf Database
     * @return {THREE.Mesh}
     * @memberof DXFVectorizer
     */
    __drawArc(entity, dxfDb) {
        let startAngle = 0,
            endAngle = 0;
        if (entity.type === &apos;CIRCLE&apos;) {
            startAngle = entity.startAngle || 0;
            endAngle = startAngle + 2 * Math.PI;
        } else {
            startAngle = entity.startAngle;
            endAngle = entity.endAngle;
        }

        let curve = new THREE.ArcCurve(0, 0, entity.radius, startAngle, endAngle);

        let points = curve.getPoints(32);
        let geometry = new THREE.BufferGeometry().setFromPoints(points);

        let material = new THREE.LineBasicMaterial({
            color: this.__getColor(entity, dxfDb)
        });

        let arc = new THREE.Line(geometry, material);
        arc.position.x = entity.center.x;
        arc.position.y = entity.center.y;
        arc.position.z = entity.center.z;

        return arc;
    }

    /**
     * Vectorize Solid
     * @private
     * @param {Object} entity - entity object
     * @param {Object} dxfDb - dxf Database object
     * @return {THREE.Mesh}
     * @memberof DXFVectorizer
     */
    __drawSolid(entity, dxfDb) {
        let material,
            verts,
            geometry = new THREE.Geometry();

        verts = geometry.vertices;
        verts.push(new THREE.Vector3(entity.points[0].x, entity.points[0].y, entity.points[0].z));
        verts.push(new THREE.Vector3(entity.points[1].x, entity.points[1].y, entity.points[1].z));
        verts.push(new THREE.Vector3(entity.points[2].x, entity.points[2].y, entity.points[2].z));
        verts.push(new THREE.Vector3(entity.points[3].x, entity.points[3].y, entity.points[3].z));

        // Calculate which direction the points are facing (clockwise or counter-clockwise)
        let vector1 = new THREE.Vector3();
        let vector2 = new THREE.Vector3();
        vector1.subVectors(verts[1], verts[0]);
        vector2.subVectors(verts[2], verts[0]);
        vector1.cross(vector2);

        // If z &lt; 0 then we must draw these in reverse order
        if (vector1.z &lt; 0) {
            geometry.faces.push(new THREE.Face3(2, 1, 0));
            geometry.faces.push(new THREE.Face3(2, 3, 1));
        } else {
            geometry.faces.push(new THREE.Face3(0, 1, 2));
            geometry.faces.push(new THREE.Face3(1, 3, 2));
        }

        material = new THREE.MeshBasicMaterial({
            color: this.__getColor(entity, dxfDb)
        });

        return new THREE.Mesh(geometry, material);
    }

    /**
     * Vectorize Text
     * @private
     * @param {Object} entity - entity dxfDb
     * @param {Object} dxfDb - dxf Database
     * @return {THREE.Mesh}
     * @memberof DXFVectorizer
     */
    __drawText(entity, dxfDb) {
        let geometry,
            material,
            text;

        if (!this.font) return console.warn(&apos;Text is not supported without a Three.js font loaded with THREE.FontLoader! Load a font of your choice and pass this into the constructor. See the sample for this repository or Three.js examples at http://threejs.org/examples/?q=text#webgl_geometry_text for more details.&apos;);

        geometry = new THREE.TextGeometry(entity.text, {
            font: this.font,
            height: 0,
            size: entity.textHeight || 12
        });

        material = new THREE.MeshBasicMaterial({
            color: this.__getColor(entity, dxfDb)
        });

        text = new THREE.Mesh(geometry, material);
        text.position.x = entity.startPoint.x;
        text.position.y = entity.startPoint.y;
        text.position.z = entity.startPoint.z;

        return text;
    }

    /**
     * Vectorize Point
     * @private
     * @param {Object} entity - entity dxfDb
     * @param {Object} dxfDb - dxf Database
     * @return {THREE.Mesh}
     * @memberof DXFVectorizer
     */
    __drawPoint(entity, dxfDb) {
        let geometry, material, point;

        geometry = new THREE.Geometry();

        geometry.vertices.push(new THREE.Vector3(entity.position.x, entity.position.y, entity.position.z));

        // TODO: could be more efficient. PointCloud per layer?

        let numPoints = 1;

        let color = this.__getColor(entity, dxfDb);
        let colors = new Float32Array(numPoints * 3);
        colors[0] = color.r;
        colors[1] = color.g;
        colors[2] = color.b;

        geometry.colors = colors;
        geometry.computeBoundingBox();

        material = new THREE.PointsMaterial({
            size: 0.05,
            vertexColors: THREE.VertexColors
        });

        return new THREE.Points(geometry, material);
    }

    /**
     * Vectorize Block
     * @private
     * @param {Object} entity - entity dxfDb
     * @param {Object} dxfDb - dxf Database
     * @return {THREE.Mesh}
     * @memberof DXFVectorizer
     */
    __drawBlock(entity, dxfDb) {
        let block = dxfDb.blocks[entity.name];

        if (!block.entities) return null;

        let group = new THREE.Object3D();

        if (entity.xScale) group.scale.x = entity.xScale;
        if (entity.yScale) group.scale.y = entity.yScale;

        if (entity.rotation) {
            group.rotation.z = entity.rotation * Math.PI / 180;
        }

        if (entity.position) {
            group.position.x = entity.position.x;
            group.position.y = entity.position.y;
            group.position.z = entity.position.z;
        }

        for (let i = 0; i &lt; block.entities.length; i++) {
            let childEntity = this.drawEntity(block.entities[i], dxfDb, group);
            if (childEntity) group.add(childEntity);
        }

        return group;
    }

    /**
     * Compute entity Color
     * @private
     * @param {Object} entity - entity dxfDb
     * @param {Object} dxfDb - dxf Database
     * @return {THREE.Mesh}
     * @memberof DXFVectorizer
     */
    __getColor(entity, dxfDb) {
        let color = 0x000000; //default
        if (entity.color) color = entity.color;
        else if (dxfDb.tables &amp;&amp; dxfDb.tables.LAYER &amp;&amp; dxfDb.tables.LAYER.LAYER[entity.layer])
            color = dxfDb.tables.LAYER.LAYER[entity.layer].color;

        if (color == null || color === 0xffffff) {
            color = 0x000000;
        }
        return color;
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
